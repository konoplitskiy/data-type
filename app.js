/* Типы данных  h1*/
/* Переменная в js может содержать любые типы данных. Изночально это может быть строка, затем мы можем переприсвоить ей значение на число  */


//Сдесь ошибки нет
let info = 'Hello';
info = 23;

/* Языки програмирования в которых такое возможно, называются 'Динамически типизированными'. Это означает, что тип данных не привязан к определённой перемене */

/* На данный момент в языке javascript 8 типов данных */

//Числа h2

// Infinity h3

/* 
    Числа в javascript бывают целочисленными и с плавающей точкой. Также к ним относятся числовые значения  это NaN  и Infinity.
    Infinity представляет собой бесконечность.Мы можем получить в результате деление на ноль какого-либо числа. Infinity можно присвоить значение к переменной, без проведённых операции. 

*/
console.log(2 / 0); //Infinity

/* Бесконечность всегда больше любого числа */

if(Infinity > 32343547589475){
    console.log('Infinity больше, чем заданное число');
}

// NaN h3

/*
 Числовое значение NaN, мы получаем результате проведённых математических операции.
  Например, когда мы строку пытаемся поделить на число.
*/

console.log('строка' / 2); //NaN

/*
  Нужно запомнить любая операция с NaN , возращает NaN.
*/

console.log(NaN * 2); //NaN

/*
    Математические операции в javascript безопасны.Нам не выведет ошибку, какая-либо математическая операция, в худшем случае, мы просто получим NaN  и наш срипт продолжит выполняться.
*/

/*
    Специальные значение Infinity и NaN относятся к типу "число".
*/
/*
    В javascript мы можем также сокращать наши числовые значение в которых присутсвует много нулей,
    миллион или миллиард.
*/

let num1 = 1e6;
console.log(num1); //1000000
let num2 = 1e9; //1 миллиард

/*
    Нули в числовом значении можно добовлять, как в правую сторону, так и в левую сторону данного числа.
*/

let num3 = 1e-6;
console.log(num3); //0.000001
let num4 = 3e-6;
console.log(num4); //0.000003
console.log(num3 + num4); // 0.000004


// BigInt h2

/*
   Этот тип данных, который нам нужен,  для работы с большими числами, 
   больше чем максимальное число в javascript 
   чем 2 в53 степени (или меньше, чем -2 в53 степени для отрицательных).
   Чтоб создать BigInt,  нужно в конце наших чисел добавить n.
*/   

let bigNum = 3213321382713872819309389489384n;
console.log(bigNum);


/*
    Мы можем выполнят, такие же операции, как и с простыми числами.
    BigInt  работает только с целыми числами.
*/
console.log(1n + 2n); //3n
console.log(7n / 2n); // 3n


/*
    Как мы видим, выше при делении, в консоль мы получили резульат 3n. 
    Это говорит о том, что BigInt работает только с целыми числами.
*/

/*
    Мы не можем их смешивать с обычными цифрами при математических операции.
    Почучим в консоль ошибку : Cannot mix BigInt and other types, use explicit conversions.
*/

//console.log(3n + 2);  //Cannot mix BigInt and other types, use explicit conversions


/*
    При сравнении, больше или меньше, между простыми числами и BigInt , всё будет выглядить как обычно,
    но сравнивать мы можем только при не строгом равенстве, напомню это  === .
*/

console.log(3n > 2); //true
console.log(1n > 2); //false
console.log(2n == 2); //true
console.log(2n === 2); //false

/*
    В логических опарации, ведёт себя как и обычное число.
*/


// Строка  h3

/*
    Строка в javascript, всегда должна заключена быть  в ковычки.
*/

let str = "Двойнынй ковычки";
let str2 ='С одинарными как-то чище';
let str3 = `Ну а это, супер ковычки, в которые можно записывать переменные или операции ${2 + 2}`;

/*
    Между двойными и одинарными ковычками нет ни какой разницы, а вот в обратных ковычках, есть большая сила.
*/

/*
   Обратные ковычки появились чуть позже, по этому они гибче. Мы вот например, можем переносить так строку.

*/

let str4 = `Это строка и 
я её могу перенести`;  // Ошибки не будет

// let str5 = 'С двойными и 
// одинарными ковычками так не получится' //Ошибка




// Булевый (логический) тип h2


/*
   
Булевой тип, может принимать два значение,  это true (истина), false(ложь).

*/

let isAvtive = true;
let notActive = false;

/*
    true или false  мы можем получить в результате сравнений:
*/
let result = 2 > 1;
console.log(result); //true


/*
   Значение  null  h2
*/

/*
    Это значение, которое представляет собой «ничего», «пусто» или «значение неизвестно».
*/

let personName = null;
console.log(personName);//null

/*
    Выше показанно, что переменная неизвестна , и не имеет никакого значения.
*/


/*
   Значение  undefined h2
*/

/*
    По сути оно такое же как и null. Обычно мы получаем undefined, когда переменная обьявленна, но ей не присвоенно значение.
*/



/*
    object h2
*/ 

/*
    Обьект это особенный тип данных. Все которые выше были типы данных, они были примитивные.
    Обьект может содержать в себе колекцию разных типов данных.
*/ 

let user = {
    name: 'Gena',
    age:32,
    work: true
}


/*
    symbol h2
*/ 

/*
    Символ (анг. Symbol) — это уникальный и неизменяемый тип данных, который может быть использован как идентификатор для свойств объектов. Symbol новый тип данных который быв введён в стандарт ES6.
    Создадим символ.
*/ 

let symbolOne = Symbol('newSymbol');
let symbolTwo = Symbol('newSymbol');
console.log(symbolOne  === symbolTwo );//false


/*
   Как мы и говорили, что это уникальный тип данных , и как мы видим, что они не равны  даже если значения одинаковы.
*/ 


/*
   Создадим при помощи метода for ещё один символ. В качестве аргумента, передадим точно такое же имя и проверим равенство символов.
*/ 

let symbolThree = Symbol.for('oldSymbol');
let symbolFour = Symbol.for('oldSymbol');
console.log(symbolThree  === symbolFour );//true

/*
  Получили результат true.  symbolThree и  symbolFour это один и тот же символ .Когда мы используем метод for, он пытается найти  символ который мы передели в параметры с таким же именем, если он не найдёт имя, то создаст новый символ,если же символ будет найдет, то переменной которой мы присвоем вызов функции Symbol  будет присвоена ссылка на существующий символ с таким же именем .К символу мы можем обратится в любом месте нашего скрипта, они заносятся в глобальный реестр, но только если мы используем метод for.
*/ 

let personMan = {
    name: 'Jack',
    age:27,
    [Symbol.for('password')]: 'dkaosof090',
    [Symbol.for('address')]: 'volkova19'
}
console.log(personMan);


/*
    Посмотреть все символы у обьекта  можно с помощью метода getOwnPropertySymbols.
    Тип данных который вернёт  метод getOwnPropertySymbols ,  это массив.
*/ 

console.log(Object.getOwnPropertySymbols(personMan));


//Оператор typeof 

/*
  Оператор typeof позволяет нам увидеть, какой тип данных сохранён в переменной.
  У него есть два синтаксиса:
   Синтаксис оператора: typeof x.
   Синтаксис функции: typeof(x)
   Грубо говоря со скобками и без.
*/ 

console.log(typeof(10)); //number
console.log(typeof 'number'); //string